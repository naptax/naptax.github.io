---
title: PROLOG 0x002, La Stack 
layout: post
---

<img height="60" src="../images/stack.png" xmlns="http://www.w3.org/1999/html"/>    Lorsque l'on souhaite se lancer dans le reverse engineering de binaire, on pense que l'assembleur est LA barrière d'entrée complexe. En réalité, l'assembleur est d'une syntaxe simplissime, d'une logique totale et donc d'un niveau de complexité très faible. Ce qui est complexe, vient d'une erreur de départ tres rependue : commencer a lire du code assembleur sans avoir, au préalable, maitriser pleinement les 4 elements suivants :

1.  Le fonctionnement de la Stack
2.  Les registres
3.  Les conventions d'appels définies par l'ABI (_Application Binary Interface_)
4.  **Le fonctionnement de la Stack ;-)**

C'est pourquoi un bref rappel sur la Stack me parrait ici bénéfique : en avant toute

### C'est quoi la Stack ? 

‌

La pile est une mémoire volatile, rapide d'acces et organisée selon le principe LIFO (Last-in, First-out). On utilise l'instruction PUSH pour stocker une valeur dans la pile (on dit alors "empiler") et l'instruction POP pour extraire/dépiler<sup><a id="fnref1"></a>\[1\]</sup> la derniere valeur empilée.

* * *

1.  *Attention l'instruction POP ne supprime pas réellement les éléments de la pile, elle modifie simplement l'emplacement vers lequel pointe le registre RSP.* ↩︎


‌

- L'adresse de début de la pile est stocké dans le register RSP (ou ESP en 32-bit). 
- Le pointeur sur la fin actuelle de la pile est stockée dans le registre (RBP).
- N'oubliez pas qu'un PUSH decremente ESP et qu'un POP incrémente ESP.

Quand une fonction est éxécutée, une Stack Frame (cadre de pile) est créée pour stocker ses informations (ex: ses variables locales). Cette nouvelle stack frame vient s'empiler sur la stack du thread. Quand cette fonction est terminée, la stack frame est abandonnée. C'est-à-dire que les registres RSP et RBP pointent à nouveau sur la Stack Frame de l'appelant. Le flux d'éxecution (dont l'adresse de la prochaine instruction est stockée dans le registre RIP) continue alors dans l'appelant à l'adresse qui suit le call de l'appelé. Cette adresse de retour (*return address*) aura pour celà été sauvegardée.

Allez on illustre tout celà par des petits schémas :

‌

![](:/ee84198d0a8d43a78228cd10431a358b)

Voici une Stack frame

‌

- La valeur (c-à-d son adresse) d'EBP reste fixe pour la stack frame
- La valeur d'ESP varie (vers le haut ou vers le bas) en fonction des données (nombre et taille) empilées ou dépilées sur cette stack frame
- Vous aurez noté que cette stack frame mesure à un instant t (EBP-ESP)

Regardons maintenant sur un schéma cette histoire d'appelant (*caller*) et d'appelé (*callee*), d'un point de vue des stack frame :

‌

![](:/efe453d5d9044ba1b6aa927d19bef0ef)

Une Stack appelant-appelé

‌

### Naviguer dans la Stack

La stack est utilisée pour stocker :

1.  Les variables locales d'une fonction
2.  Des arguments d'appel d'une fonction
3.  Des adresse de retour 

**Mais o trouve t-on ces différentes informations dans la stack et comment y accede t-on ?**

On navigue dans une stack par adresses relatives (offset); relatives par rapport à son haut (c-à-d par rapport au registre ESP), ou relatives par rapport à sa base (le registre EBP).

**N'oubliez pas que sur x86/x64 l'on décrémente ESP pour monter dans la stack (par exemple au fur et à mesure des allocations mémoire statique) et que l'on incrémente ESP pour descendre dans la stack**. Au début cela est un peu pertubant, mais vous verrez, on s'y fait trés vite : "*Plus pour descendre*", "*Moins pour monter*" ;-) Par exemple pour réserver de la mémoire sur la stack, on diminue ESP de la taille à réserver : *sub esp, xxx*

#### Fonction 1 : Passage d'arguments par la stack

Il existe plusieurs conventions qui permettent de specifier les modalités de passage d'arguments à une fonction (paramètres émis par l'**appelant** et donc reçus par l'**appelé**). Nous étudierons dans un prochain billet ces différentes conventions d'appel (*convention call*). Ce qui  intéresse ici pour le moment, c'est de comprendre où et comment ces arguments passés par la stack se positionnent en mémoire. L'objectif est évidement de pouvoir accéder aux valeurs de ces paramètres.

Prenons l'appel de fonction C suivante :

‌

```
int __cdecl additionne(int x, int y, int z);
int somme=additionne(20, 30,40); 
```

, appel que notre compilateur aurait traduit par le code assembleur suivant (sur un x86 32-bit<sup><a id="fnref1"></a>\[1\]</sup>)

```
push 28      ; 40 en decimal
push 1eh     ; 30 en decimal
push 14      ; 20 en decimal
call additionne 
```

* * *

1.  je précise ici sur x86, car sur ARM et x64 le mot clé __cdecl n'est pas pris en compte par le compilateur. En effet, la convention veut que sur processeur ARM et x64, les parametres soient passés autant que possible par les registres, puis seulement ensuite par la stack. ↩︎


‌

La stack serait alors la suivante :

Et voilà donc comment assigner à des registres, les valeurs de nos 3 arguments quand nous sommes dans la fonction appelée (*callee*) :

‌

```
mov eax, xxx
mov ebx,[ebp+x]
mov ecx, [ebp+y] 
```

‌

##### Fonction 2 : Stocker les variables locales

Passons maintenant aux différentes conventions d'appel : ici

855 words

[](https://ghost.org/help/using-the-editor/)