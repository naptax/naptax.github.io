---
title: PROLOG 0x002, La Stack 
layout: post
---

<img height="60" src="../images/stack.png" xmlns="http://www.w3.org/1999/html"/>    Lorsque l'on souhaite se lancer dans le reverse engineering de binaire, on pense que l'assembleur est LA barrière d'entrée complexe. En réalité, l'assembleur est d'une syntaxe simplissime, d'une logique totale et donc d'un niveau de complexité très faible. Ce qui est complexe, vient d'une erreur de départ tres répandue : commencer à lire du code assembleur sans avoir, au préalable, maitriser pleinement les 4 elements suivants :

1.  Le fonctionnement de la Stack
2.  Les registres
3.  Les conventions d'appels définies par ```l'ABI (_Application Binary Interface_)```
4.  **Le fonctionnement de la Stack ;-)**

### L'ABI (Application Binary Interface)<img src="../images/abi.png" width="200" align="middle">


Une ABI définit la manière dont les structures de données et les données sont accessibles dans le code machine. Pour exemple les conventions d'appels (que nous allons voir un peu plus bas) sont définies au sein des ABI

Adhérer à une ABI (qui peut, ou non, être officiellement standardisée) est généralement le travail d'un compilateur, d'un système d'exploitation. Cependant, un développeur peut avoir à traiter directement avec une ABI lors de l'écriture d'un programme utilisant plusieurs langages de programmation (ex: C pour Windows et Assembleur), ou même de la compilation d'un programme écrit dans le même langage avec différents compilateurs.

Quand on manipule du code assembleur issu du reverse d'un programme binaire, nous sommes dans l'obligation de prendre en compte l'ABI qu'il utilise.

Les détails couverts par une ABI incluent les éléments suivants :
1. **Jeu d'instructions** du processeur, avec des détails tels que la structure des registres, l'organisation de la pile, les types d'accès à la mémoire, etc.

2. **Tailles**, dispositions et alignements des types de données de base auxquels le processeur peut accéder directement

3. **Convention d'appel**, qui contrôle la façon dont les arguments des fonctions sont passés et les valeurs de retour récupérées par exemple, il contrôle les éléments suivants :
   - Si tous les paramètres sont passés sur la pile, et/ou certains sont passés dans des registres
   - Quels registres sont utilisés pour quels paramètres de fonction
   - Si le premier paramètre de fonction passé sur la pile est poussé en premier ou en dernier

4. Comment une application doit effectuer des appels système au système d'exploitation, et si l'ABI spécifie des appels système directs plutôt que des appels de procédure, les numéros d'appel système

5. Dans le cas d'un système d'exploitation complet, l'ABI de l'OS normalise le format binaire des fichiers objets, des bibliothèques binaires, ...


***

### Mais c'est quoi la Stack ? <img src="../images/stackicon.png" width="200" align="middle">

La pile est une mémoire volatile, rapide d'accès et organisée selon le principe LIFO (Last-in, First-out). On utilise l'instruction ```PUSH``` pour stocker une valeur dans la pile (on dit alors "empiler") et l'instruction ```POP``` pour extraire/dépiler [^1] la dernière valeur empilée et la placer dans un des registres du CPU.

- L'adresse de début de la pile est stockée dans le registre RSP (ou ESP en 32-bit).
- Le pointeur sur la position actuelle dans la pile est stockée dans le registre (RBP).
- N'oubliez pas qu'un PUSH décremente ESP et qu'un POP incrémente ESP.

Quand une fonction est exécutée, une Stack Frame (cadre de pile) est créée pour stocker ses informations (ex: ses variables locales). Cette nouvelle stack frame vient s'empiler sur la stack du thread. Quand cette fonction est terminée, la stack frame est abandonnée. C'est-à-dire que les registres RSP et RBP pointent à nouveau sur la Stack Frame de l'appelant . Le flux execution (dont l'adresse de la prochaine instruction est stockée dans le registre RIP) continue alors dans l'appelant à l'adresse qui suit le call. Cette adresse de retour (*return address*) ayant éte préalablement sauvegardée.

Allez on illustre tout celà par des petits schémas :


Voici une Stack frame



- La valeur (c-à-d son adresse) d'EBP reste fixe pour la stack frame
- La valeur d'ESP varie (vers le haut ou vers le bas) en fonction des données (nombre et taille) empilées ou dépilées sur cette stack frame
- Vous aurez noté que cette stack frame mesure à un instant t (EBP-ESP)

Regardons maintenant sur un schéma cette histoire d'appelant (*caller*) et d'appelé (*callee*), d'un point de vue des stack frame :



Une Stack appelant-appelé



### Naviguer dans la Stack

La stack est utilisée pour stocker :

1.  Les variables locales d'une fonction
2.  Des arguments d'appel d'une fonction
3.  Des adresses de retour

**Mais où trouve t-on ces différentes informations dans la stack et comment y accede t-on ?**

On navigue dans une stack par adresses relatives (offset); relatives par rapport à son haut (c-à-d par rapport au registre ESP), ou relatives par rapport à sa base (le registre EBP).

**N'oubliez pas que sur x86/x64 l'on décrémente ESP pour monter dans la stack (par exemple au fur et à mesure des allocations mémoire statique) et que l'on incrémente ESP pour descendre dans la stack**. Au début cela est un peu perturbant, mais vous verrez, on s'y fait très vite : "*Plus pour descendre*", "*Moins pour monter*" ;-) Par exemple pour réserver de la mémoire sur la stack, on diminue ESP de la taille à réserver : 

```asm 
sub esp, <taille à réserver>
```

#### Fonction 1 : Passage d'arguments par la stack

Il existe plusieurs conventions qui permettent de specifier les modalités de passage d'arguments à une fonction (paramètres émis par l'**appelant** et donc reçus par l'**appelé**). Nous étudierons plus bas ces différentes conventions d'appel (*convention call*). Ce qui intéresse ici pour le moment, c'est de comprendre où et comment ces arguments passés par la stack se positionnent en mémoire. L'objectif est évidement de pouvoir accéder aux valeurs de ces paramètres.

Prenons l'appel de fonction C suivante :

```c
int __cdecl additionne(int x, int y, int z);
int somme=additionne(20, 30,40); 
```

, appel que notre compilateur aurait traduit par le code assembleur suivant (sur un x86 32-bit[^2])

```asm
push 28      ; 40 en decimal
push 1eh     ; 30 en decimal
push 14      ; 20 en decimal
call additionne 
```

La stack serait alors la suivante :

Et voilà donc comment assigner à des registres, les valeurs de nos 3 arguments quand nous sommes dans la fonction appelée (*callee*) :


```asm
mov eax, xxx
mov ebx,[ebp+x]
mov ecx, [ebp+y] 
```



##### Fonction 2 : Stocker les variables locales

### Les conventions d'appel
Comme leur nom l'indique, les conventions d'appels définissent des règles communes en matière de passage d'arguments et de valeurs retour vers et par une fonction. Bah oui me direz vous... mais voilà, la difficulté c'est qu'il existe plusieurs de ces conventions. Par exemple, elles sont différentes entre un LINUX 64-bit et un WINDOWS 64-bit. 

Sans rentrer dans l'historique explicant cette diversité de conventions, nous allons nous concentrer uniquement sur 2 d'entres-elles :
- Linux 64-bit (_System V AMD64 ABI_)
- Windows 64-bit (_fastcall_)

#### Linux 64-bit
#### Windows  64-bit

S'il n'y a pas de registres disponibles pour les huit octets d'un argument, l'argument entier
est passé sur la pile. Si des registres ont déjà été affectés pour environ huit octets de tels
un argument, les affectations sont annulées.
Une fois les registres assignés, les arguments passés en mémoire sont poussés sur la pile
dans l'ordre inverse (de droite à gauche21).
Pour les appels qui peuvent appeler des fonctions qui utilisent varargs ou stdargs (appels sans prototype ou appels
aux fonctions contenant des points de suspension (. . . ) dans la déclaration) %al22 est utilisé comme argument caché
pour spécifier le nombre de registres vectoriels utilisés. Le contenu de %al n'a pas besoin de correspondre
exactement le nombre de registres, mais doit être une limite supérieure sur le nombre de vecteurs
registres utilisés et est compris entre 0 et 8 inclus.
Lors du passage des arguments __m256 ou __m512 aux fonctions qui utilisent varargs ou stdarg,
des prototypes de fonction doivent être fournis. Sinon, le comportement d'exécution est indéfini.
Retour des valeurs Le retour des valeurs se fait selon le algorithme suivant :
1. Classifiez le type de retour avec l'algorithme de classification.
2. Si le type a la classe MEMORY, l'appelant fournit de l'espace pour la valeur de retour
   et passe l'adresse de ce stockage en %rdi comme s'il s'agissait du premier argument du
   fonction. En effet, cette adresse devient un premier argument "caché". Ce stockage
   ne doit chevaucher aucune donnée visible par l'appelé via d'autres noms que cet argument.
   Au retour %rax contiendra l'adresse qui a été passée par l'appelant dans %rdi.
3. Si la classe est INTEGER, le prochain registre disponible de la séquence %rax, %rdx est
   utilisé.
4. Si la classe

***

Notes

***

[^1]: _Attention l'instruction POP ne supprime pas réellement les éléments de la pile, elle modifie simplement l'emplacement vers lequel pointe le registre RSP._

[^2]: _je précise ici sur x86, car sur ARM et x64 le mot clé ```__cdecl``` n'est pas pris en compte par le compilateur. En effet, la convention exige que sur processeur ARM et x64, les paramètres soient passés autant que possible par les registres, puis ensuite par la stack._
