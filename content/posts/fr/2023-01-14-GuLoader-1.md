---
author: "Naptax"
title: "GuLoader : Analyse | Part one | (French version)"
date: "2023-01-14"
tags: 
- malware
- guloader
- loader
- dropper
draft: false
---

<center>
<img width="500" src="/images/GuLoader.png">
</center>

**Hello**,

Si vous avez suivi les diff√©rents [billets de PROLOG de ce blog]({{< relref "/posts/" >}}), alors le temps est venu de s'attaquer √† un bon client pour l'analyse de Malware, et surtout des techniques d'√©vasion et d'anti : le loader **GULOADER**. **GuLOADER c 'est un peu comme le boss de fin des techniques anti-*. En avant pour la Hard way**

# L'histoire de GuLoader
GuLoader est un dropper de Malware qui a √©t√© vu pour la premi√®re fois fin 2019. A l'√©poque il n'√©tait encore qu'un 'simple' downloader utilis√© pour diffuser des RAT tels que [AgentTesla](https://www.gatewatcher.com/malware-analysis-agent-tesla/) et Nanocore. Il est √©galement connu et r√©f√©renc√© sous le nom de **CloudEyE**).

Puis √† partir de 2020, GuLoader se mit √† **int√©grer un nombre tr√®s important de techniques d'√©vasion** ([cf. notre s√©rie sur ces techniques Anti]({{< relref "2022-12-16-Offuscation" >}})). Notamment la technique anti qui consiste √† ne pas appeler directement les fonctions d'API Windows par leur nom, mais par leur hash ([cf. notre billet pour le d√©tail de cette technique de API call by Hashing]({{< ref "2022-12-16-Offuscation#api-calling-obsfuscation" >}})). Comme dans de nombreux malware, le dropper GuLoader utilise l'algorithme de Hash ```DJB2``` qui a l'avantage d'√™tre tr√®s simple et g√©n√©rant peu de collisions.

Puis en 2021 GuLoader s'est dot√© d'une arm√©e de techniques d'Anti-debug, anti-Sandbox, anti-VM afin de rendre son analyse encore plus complexe. Cette complexification s'est accompagn√©e de l'utilisation de Visual Basic Script (VBS) pour se propager et de NSIS (Nullsoft Scriptable Install System) pour le packing et le chiffrement de son Payload. 

Nous allons ici √©tudier **une des tr√®s nombreuses versions de GuLoader**. En effet, il en existe de tr√®s nombreuses car le groupe derri√®re ce dropper est tr√®s actif et scan tous les papiers concernant leur code. **A chaque nouvelle analyse un peu s√©rieuse d'une de leur version, ils r√©agissent et modifient rapidement de mani√®re radicale leur malware**. 

Par cons√©quent, nous devrions plut√¥t dire que nous allons analyser "une version" de GuLoader plut√¥t que GuLoader. En effet chaque update modifie compl√®tement le profil du payload.

### :warning: DISCLAIMER :warning:


<center>
<img width="800" src="/images/caution.png">
</center>

<p class="disclaimer">
A partir d'ici, je fais l'hypoth√®se que vous √™tes familiers des pr√©cautions absolument n√©cessaires pour manipuler, ouvrir, analyser statiquement, debugger dynamiquement cette mati√®re dangereuse que sont les MALWARES. Si cela n'est pas le cas, alors il faut tout de suite vous arr√™ter ici si vous ne voulez pas √™tre infect√©s (et infecter) par les √©chantillons que nous allons manipuler. Ne le prenez pas √† la l√©g√®re car l'unique finalit√© des malwares et autres dropper que nous allons analyser est de vous faire du tort, et ce, en utilisant des m√©canismes puissants, agressifs et furtifs.
</p>

Sur mon Blog, je ne souhaite pas √©crire des articles sur comment monter son laboratoire d'analyse √† base de VM. En effet, pour moi monter ce type de labo est une tache n√©cessaire mais dans laquelle je trouve peu d'int√©r√™t intellectuel, je vous invite donc √† suivre par exemple cet excellent guide afin de monter votre labo. Ainsi, vous pourrez faire exploser des malwares avec le plus de s√©curit√© possible. Sachez n√©anmoins que m√™me avec beaucoup de pr√©cautions (et surtout de rigueur), **le risque z√©ro d'infection n'existe pas**.

Juste pour votre information, mon labo d'analyse est constitu√© de la mani√®re suivante:
- Je n'utilise pas mon Mac de 'daily' pour cette activit√©
- Utilisation d'un desktop orient√© Gaming **d√©di√©**, sous UBUNTU, nomm√© WOPR ;-)
- Tout est **VM VMWARE** chez moi
- Chaque Malware analys√© en Debug l'est √©videmment au sein d'une **VM** tournant sous Windows 11 avec [100% FLARE VM de MANDIANT](https://github.com/mandiant/flare-vm) d'install√© (```Host Based Indicators```)
- Les toutes derni√®res versions de **FLARE VM** fonctionnent parfaitement avec Windows 11 (contrairement aux anciennes qui avaient des probl√®mes en W10 et W11)
- Les VM INFECTED ne communiquent pas avec le r√©seau du Desktop Hote (WOPR), ni avec le WIFI et internet : elles disposent de leur propre r√©seau virtuel priv√© en vase clos
- J'utilise l'excellent **RemNux** pour √©muler les services internet de base (HTTPx, SSHD, SMTP, SMB, ...) et ainsi analyser les actions r√©seau des vilains canards (```Network Based Indicators```)
- L'ensemble des VM INFECTED sont stock√©es sur un disque dur SSD **externe** et **d√©di√©**
- Le DD externe d√©di√© avec son sticker BIOHAZARD est syst√©matiquement d√©branch√© de l'h√¥te et rang√© au tiroir
- D√©finition et strict respect de **Conventions de nommage des fichiers et des extensions** au sein des VM INFECTED
- Utilisation d'aucune extension dans les navigateurs des VM Infected (ex: n'allez pas y installer votre password manager pour gagner du temps )
- ET SURTOUT, je ne t√©l√©charge JAMAIS mes samples sur le Darkweb (je pr√©f√®re GITHUB, MALWARE BAZAR oy ANY.RUN)

<p class="disclaimer">
Formez-vous sur tout cela AVANT de passer √† la suite. Ne pas le faire vous expose de mani√®re certaine √† de gros probl√®mes.
</p>

<center>
<img width="800" src="/images/caution.png">
</center>

<center>
<img width="300" src="/images/explosion.png">
</center>

# GULOADER: On ouvre la bo√Æte

Vous avez lu le ```Disclaimer``` ci-dessus ? Alors on y va.

Ce qui caract√©rise GuLoader, et donc fait son int√©r√™t d'√©tude, ce sont les nombreuses techniques d'anti-* qu'il utilise:

Contre les analyses dynamiques :
- **Anti-VM** : GuLoader v√©rifie l'absence de VMWare, QEMU, VirtualBox et se termine lors de toute d√©tection
- **Anti-Sandbox** : Le malware v√©rifie l'absence de syst√®me de sand-boxing tel que ```Cuckoo Sandbox```
- **Anti-Debug** : GuLoader v√©rifie si il est ex√©cut√© sous un debugger tel que ```WinDbg``` ou ```OllyDbg```

Pour complexifier l'analyse statique :
- **Appels des API Windows**, non pas par leur nom, mais par leur hash ```DJB2```
- **Utilisation d'un VEH (Vectored Exception Handler)** pour piloter le flux d'ex√©cution (plut√¥t que par des JUMP et des CALL)
- **Offuscation du binaire et utilisation d'_opaque predicates_**

Dans cette article, nous allons nous int√©resser au Loader et √† la d√©sofuscation du shellcode. Nous traiterons la suite de l'analyse dans les articles suivants.

## Le script NSIS

Nous allons vite passer cette partie car l√† n'est pas l'aspect int√©ressant ce GuLoader.

Depuis quelque temps, mes analyses statiques de binaires commencent toute par un scan avec l'excellent [Detect It Easy](https://github.com/horsicq/Detect-It-Easy/tree/master/db) cod√© par [@horsicq](https://twitter.com/horsicq). 

Voici ce que DiE (lanc√© ici en mode console) pense de notre binaire myst√®re:
``` bash
naptax@WOPR:~/diec 14d52119459ef12be3a2f9a3a6578ee3255580f679b1b54de0990b6ba403b0fe.7z 

PE32
    Installer: Nullsoft Scriptable Install System(3.08)[lzma,solid]
    Linker: Microsoft Linker(6.0*)[GUI32,signed]
    Overlay: NSIS data(-)[-]

```
DiE nous indique que le binaire pourrait √™tre une archive compress√©e au format **NSIS (Nullsoft Scriptable Install System)**.
Qui dit NSIS, dit _7-Zip_, alors ouvrons ce binaire avec _7-Zip_:

<img width="500" src="/images/guloader/guloader.1.png">

Encore une fois, _Detect It Easy_ avait vu juste. 
Int√©ressons-nous √† ce gros fichier ```rudesbies.Par```

L√† encore, un premier scan avec DiE:

``` bash
naptax@WOPR:~/diec rudesbies.Par
```
Mais cette fois, rien de connu dans la [DB de signatures DiE](https://github.com/horsicq/Detect-It-Easy/tree/master/db).


## D√©sofuscation du Shell Code Phase 1

Chargeons alors ce binaire dans **BINARY NINJA**. La premi√®re partie int√©ressante est ce petit bout de code, je vous ai mis en commentaire ce que nous pouvons en tirer:
Jusqu'√† l'adresse ```+0x00000025```, que du JUNK Code n'ayant aucun impact sur le flux d'ex√©cution.

La premi√®re instruction int√©ressante se situe √† ```+0x00000025```: un JMP qui nous m√®ne sur un premier CALL ```+0x0000002A``` 

<img width="700" src="/images/guloader/guloader-bn-1.png">

L√† encore, beaucoup de JUNK code, c'est pourquoi je n'ai conserv√© ci-dessous que les instructions de la fonction ```+0x0000002a``` qui nous int√©ressent:

<img width="700" src="/images/guloader/guloader-bn-2.png">



``` nasm
**************************************************************
*                          FUNCTION                          *
**************************************************************
undefined FUN_0000002a()
   
   (...)
        00000048 5f              POP        EDI   
   
   (...)
        00000065 31 d2           XOR        EDX,EDX

LAB_00000090:

    (...)
        000000b5 81 34 17        XOR        dword ptr [EDI + EDX*0x1],0x919e1e2e
    
    (...)
        000000db 83 c2 04        ADD        EDX,0x4
        000000f7 81 fa 08        CMP        EDX,0x17208
        000000fd 75 91           JNZ        LAB_00000090

```
- Le ```POP EDI``` stocke dans EDI la _return address_ mis sur la pile au moment du ```CALL +0x0000002A``` 
- On met EDX √† 0 (pour peut-√™tre pr√©parer une boucle ...)
- Ah :-) on XOR le code avec la cl√© ```0x91 9e 1e 2e```
- Et on boucle 0x17208/4 fois, en avan√ßant par 4 octets

**Ok, on a donc une premi√®re boucle qui XOR tout le code √† partir de l'adresse ```0x0000014e``` avec ```0x919e1e2e```  comme cl√©.**

Cr√©ons un petit bout de RUST pour d√©chiffrer ce code offusqu√©:
``` rust
use std::fs::File;
use std::io::prelude::*;
use std::io::{BufReader, BufWriter};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt}; 

fn main() {
    let file = File::open("/home/naptax/tmp/rudesbies.Par").unwrap(); // J ouvre le fichier

    let mut reader = BufReader::new(file); // J'en produis un Buffer
    let mut enc_code = vec![]; // Cr√©e un nouveau vecteur contenant des u8

    reader.read_to_end(&mut enc_code).unwrap(); // Charge le contenu du buffer dans mon vecteur
    
    let code_offset = 0x0000014E; // offset du d√©but du code √† XORer 
    enc_code = enc_code[code_offset..].to_vec();
    
    let key: u32 = 0x919E1E2E; // la cl√© avec laquelle est r√©alis√© le XOR

    let mut out = vec![]; // Cr√©e un vecteur qui va recevoir le code d√©chiffr√©
    
    for i in 0..enc_code.len() {
        out.push(enc_code[i] ^ key.to_le_bytes()[i % 4]); // fait le XOR
    }
    
    let mut file = File::create("/home/naptax/tmp/stage2.bin").unwrap();
    let mut writer = BufWriter::new(file);
    
    writer.write_all(&out).unwrap();
}
```

Si vous pr√©f√©rez proc√©der au d√©chiffrement du code XOR√© en **interne dans  :heart: BINARY NINJA  :heart:**, plut√¥t qu'en externe (ici en RUST), alors voici le code Python pour BINARY NINJA:

``` Python
def decrypt(_address, _key, _len):
	xor_key = Transform['XOR']
	address = _address
	key = _key
	for i in range(_len):
		enc_str = bv.read(address, 4)
		decrypted_str = xor_key.decode(enc_str, {'key': key.to_bytes(4, 'little')})
		bv.write(address, decrypted_str)
		address += 4

key = 0x919E1E2E
code_offset = 0x0000014E

decrypt(0x0000014E,0x919E1E2E,0x16f55)
```

J'utilise ici le ```transformer XOR ```, directement fourni par l'API de BINARY NINJA :heart:

Allez, sauvegardons ce nouveau binaire fra√Æchement d√©chiffr√© et regardons ce **stage2.bin** avec :heart: BINARY NINJA :heart: (ou votre Disassembleur pr√©f√©r√©).

## D√©sofuscation du Shell Code Phase 2 : Arriv√©e du hashing

Une premi√®re lecture du code d√©sassembl√© laisse sceptique: Encore et encore du JUNK code :-(

N√©anmoins, √† force de JMP vers des JMP de CALL ;=) on fini par identifier tout de m√™me plusieurs fonctions qui semblent proc√©der au calcul de constantes, et ce afin de les masquer.
Et en RE, quand on constate que quelqu'un s'est donn√© du mal pour masquer une information : c'est l√† que l'on doit chercher ;-)

<center>
<i class="fa fa-low-vision fa-1x" style="color:green;"> </i>
</center>

En ```0x1308C```, on voudrait nous masquer la constante **0x10000000** en la calculant par un ```hex((0x191AE730 ^ 0x320EB5D5 ^ 0xB8DB25E1) + 0x6C3088FC)```
<img width="750" src="/images/guloader/guloader-bn-0x1308c.png">

<center>
<i class="fa fa-low-vision fa-1x" style="color:green;"> </i>
</center>

Puis en ```0x127C1```, on voudrait nous masquer la constante **0x539** en la calculant par un ```hex((0x96900857 + 0x10E451D0) ^ 0xAA6DFF89 ^ 0xD19A097)```

 <center>
<i class="fa fa-low-vision fa-1x" style="color:green;"> </i>
</center>


Et √† nouveau en ```0x132C9```, on voudrait nous masquer la constante **0x61** en la calculant par un ```hex((0xE22ECFA7 ^ 0xD05F809C ^ 0x4E1C381C) - 0x7C6D76C6))```

<center>
<i class="fa fa-low-vision fa-1x" style="color:green;"> </i>
</center>

<img width="750" src="/images/guloader/guloader-bn-0x132c9.png">

Continuons le flux d'execution √† la recherche d'autres "constantes indices" qui pourraient √©clairer cette bien vilaine grotte toute obscure qu'est ce loader GuLoader ...


Et on arrive enfin en **0x12AD5**, avec la fonction suivante:  <i class="fa fa-lightbulb-o fa-2x" aria-hidden="true" style="color:green;"> </i>

**Cette fonction n'a pas l'apparence de JUNK code et semble impl√©menter un algo bien r√©el:**

<center>
<img width="750" src="/images/guloader/guloader-bn-0x12ad5.png">
</center>

Si vous avez suivi [mon petit article sur les techniques d'anti-disassembly]({{< ref "2022-12-16-Offuscation#api-calling-obsfuscation" >}}), alors **la constante 0x1505h (5381d) a du retenir votre attention**.

[En effet **5381** est une "constante signature" dans l'algorithme de hash **DJB2**](http://www.cse.yorku.ca/~oz/hash.html). Cette algo de hash est tr√®s souvent utilis√© pour faire du hashing dans les malwares (tout comme la valeur 256 caract√©rise un chiffrement RC4: [cf mon article sur ce sujet]({{< ref "2022-12-02-RC4" >}})). Il est simple, rapide et avec tr√®s peu de collisions.



On aurait donc cette fonction en 0x12AD5 qui impl√©menterait un hash DJB2. On va donc prendre cette hypoth√®se et nommer la fonction comme une ```maybe_calcul_hash()```.

Regardons maintenant **qui appelle cette fonction de hash**, pour voir si notre hypoth√®se tient la route:
<img width="750" src="/images/guloader/guloader-bn-0x12ad5-Callers.png">



Mais dites donc on ne serait pas en train d'essayer de nous masquer des **appels API Windows par la technique d'API Hash Calling en utilisant un Hash DJB2** ([ici sur mon blog]({{< ref "2022-12-16-Offuscation#api-calling-obsfuscation" >}})) **??? !!**

Dans tous les cas, les auteurs de ce machin se sont donn√©s bien du mal pour nous le cacher...

**Continuons notre enqu√™te ...**

<center>
<img width="700" src="/images/unboxing.png">
</center>

## D√©sofuscation du Shell Code Phase 3 : Les fonctions Windows appel√©es
Mais alors, il appelle quoi comme fonctions Windows et avec quels param√®tres ce _f..ing_ GuLoader (_MD5:14d52119459ef12be3a2f9a3a6578ee3255580f679b1b54de0990b6ba403b0fe_) ?

Pour d√©terminer les valeurs d'entr√©e et de sortie des param√®tres de cette fonction lors de ces 7 appels, il existe 6 cat√©gories de techniques:

1. Continuer en **Analyse Statique manuelle** sous BINARY NINJA
2. Switcher en **Analyse Dynamique manuelle** par une ex√©cution sous un debugger
3. Utiliser un framework de simulation dynamique pour coder et simuler notre fonction (ex: le sublime [UNICORN](https://www.unicorn-engine.org/))
4. Adopter une approche de **Static Binary Instrumentation (SBI)**
5. Utiliser un moteur de **Dynamic Binary Instrumentation (DBI)**, tel que __Pin d'Intel__, [FRIDA](https://frida.re/) ou [QBDI de Quarklab](https://qbdi.quarkslab.com/)  

Au vue des de la r√©putation de GuLoader d'√™tre truff√© d'anti-debug partout dans son code, j'√©carte √† ce stade une analyse sous debugger. Je prends donc le parti d'essayer de continuer en analyse statique manuelle et de me rabattre en cas d'√©chec sur les armes lourdes que sont les DBI (FRIDA, QBDI)

Travaillons donc la fonction et son second appel en IL sous BINARY NINJA:
- Rename des variables pour plus de visibilit√© 
- Transformation en NOP tout ce qui me semble √™tre du JUNK Code
- Fusion de param√®tres

Voici notre code revers√© en Pseudo-C un peu refactor√©. C'est mieux, mais √ßa reste tout de m√™me tr√®s p√©nible √† lire (je vous √©pargne le code appelant car c'est un vrai cauchemar de RE):

``` c
üîñ00012ad5  int32_t __convention("fastcall") maybe_calcul_hash(uint32_t arg1, int32_t arg2, void* arg3 @ ebp, 
üîñüîñ00012ad5      int32_t arg4 @ edi, void* ptrOnAFunction)

00012ad5  {
00012ad5      void* esi = ptrOnAFunction;
00012ad9      uint32_t var_4 = ((uint32_t)arg4);
00012adb      arg4 = 51187;
00012adf      arg4 = var_4;
üîñ00012afa      int32_t p = 5381;
00012b32      while (true)
00012b32      {
00012b32          int32_t ebx;
00012b32          *(int32_t*)((char*)arg3 + 485) = ebx;
00012b88          int32_t var_6_1 = p;
00012b88          char var_a_1 = arg1;
00012b88          int32_t var_12 = 64;
00012b88          int32_t* var_16_1 = &var_12;
00012b89          p = -106;
00012b93          int32_t eax_1 = var_6_1;
00012b9e          if (*(int8_t*)esi != 64)
00012b96          {
00012ba7              *(int32_t*)((char*)arg3 + 548) = arg2;
00012bd1              arg2 = *(int32_t*)((char*)arg3 + 548);
00012bd7              if (*(int8_t*)esi != 63)
00012bcf              {
00012be0                  *(int8_t*)((char*)arg3 + 562) = eax_1;
00012be6                  eax_1 = *(int8_t*)esi;
00012c1d                  bool cond:2_1 = eax_1 == 36;
00012c1f                  eax_1 = *(int8_t*)((char*)arg3 + 562);
00012c25                  if ((!cond:2_1))
00012c25                  {
00012c2d                      *(int8_t*)((char*)arg3 + 373) = var_a_1;
00012c41                      if (*(int8_t*)esi < -92)
00012c38                      {
00012c45                          ebx = eax_1;
00012c4e                          arg1 = ((uint32_t)*(int8_t*)esi);
üîñ00012c53                          p = ((((eax_1 << 5) + ebx) + arg1) ^ 0x1031749b);
00012c5b                          esi = ((char*)esi + 1);
00012c5c                          *(int8_t*)((char*)arg3 + 461) = arg2;
00012c64                          arg2 = *(int8_t*)esi;
00012c69                          bool cond:4_1 = arg2 != 0;
00012c6c                          arg2 = *(int8_t*)((char*)arg3 + 461);
00012c72                          if ((!cond:4_1))
00012c72                          {
00012c72                              break;
00012c72                          }
00012c72                          continue;
00012c72                      }
00012c38                  }
00012c25              }
00012bcf          }
00012c85          return eax_1;
00012c85      }
00012c7b      return p;
00012c7b  }

```

Je d√©cide donc de changer d'approche et d'essayer une approche que je n'ai jamais utilis√©e auparavant mais dont des confr√®res m'ont vant√© les m√©rites. Je vais produire [un dump m√©moire l√©ger](https://learn.microsoft.com/en-us/windows/win32/debug/minidump-files) de ce binaire en Phase 2, puis le charger avec l'outil d'√©mulation [Dumpulator](https://github.com/mrexodia/dumpulator).

### On sort Dumpulator ...

Avec ce type de code et Dumpulator, l'√©tape N¬∞1 consiste √† faire un Dump M√©moire au format _Minidump_. Rien _out of the box_ dans Binary Ninja pour en produire un, par cons√©quent je g√©n√®re ce Dump avec **x64Debug**.



<center>
<img width="300" src="/images/wip.png">
</center>
