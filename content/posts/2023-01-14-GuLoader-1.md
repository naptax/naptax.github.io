---
author: "Naptax"
title: "GuLoader : Analyse | Part one |"
date: "2023-01-14"
tags: 
- malware
- guloader
- loader
- dropper
draft: true
---

<center>
<img width="500" src="/images/GuLoader.png">
</center>

**Hello**,

Si vous avez suivi les différents [billets de PROLOG de ce blog]({{< relref "/posts/" >}}), alors le temps est venu de s'attaquer à un bon client pour l'analyse de Malware, et surtout des techniques d'évasion et d'anti : le loader **GULOADER**. **GuLOADER c 'est un peu comme le boss de fin des techniques anti-*. En avant pour la Hard way**

# L'histoire de GuLoader
GuLoader est un dropper de Malware qui a été vu pour la première fois fin 2019. A l'époque il n'était encore qu'un 'simple' downloader utilisé pour diffuser des RAT tels que [AgentTesla](https://www.gatewatcher.com/malware-analysis-agent-tesla/) et Nanocore. Il est également connu et référencé sous le nom de **CloudEyE**).

Puis à partir de 2020, GuLoader se mis a **intégrer un nombre très important de techniques d'évasion** ([cf. notre série sur ces techniques Anti]({{< relref "2022-12-16-Offuscation" >}})). Notamment la technique anti qui consiste à ne pas appeler directement les fonctions d'API Windows par leur nom, mais par leur hash ([cf. notre billet pour le détail de cette technique de API call by Hashing]({{< ref "2022-12-16-Offuscation#api-calling-obsfuscation" >}})). Comme dans de nombreux malware, le dropper GuLoader utilise l'algorithme de Hash ```DJB2``` qui a l'avantage d'être très simple et générant peu de collisions.

Puis en 2021 GuLoader s'est doté d'une armée de techniques d'Anti-debug, anti-Sandbox, anti-VM afin de rendre son analyse encore plus complexe. Cette complexification s'est accompagnée de l'utilisation de Visual Basic Script (VBS) pour se propager et de NSIS (Nullsoft Scriptable Install System) pour le packing et le chiffrement de son Payload. 

Nous allons ici étudier **une des très nombreuses versions de GuLoader**. En effet, il en existe de très nombreuses car le groupe derrière ce dropper est très actif et scan tous les papiers concernant leur code. **A chaque nouvelle analyse un peu sérieuse d'une de leur version, ils réagissent et modifient rapidement de manière radicale leur malware**. 

Par conséquent, nous devrions plutôt dire que nous allons analyser "une version" de GuLoader plutot que GuLoader. En effet chaque update modifie complètement le profil du payload.

### :warning: DISCLAIMER :warning:


<center>
<img width="800" src="/images/caution.png">
</center>

<p class="disclaimer">
A partir d'ici, je fais l'hypothèse que vous êtes familiés des précautions absolument nécessaires pour manipuler, ouvrir, analyser statiquement, debugger dynamiquement cette matière dangereuse que sont les MALWARES. Si cela n'est pas le cas, alors il faut tout de suite vous arrêter ici si vous ne voulez pas être infectés (et infecter) par les échantillons que nous allons manipuler. Ne le prenez pas à la légère car l'unique finalité des malwares et autres dropper que nous allons analyser est de vous faire du tort, et ce, en utilisant des mécanismes puissants, agressifs et furtifs.
</p>

Sur mon Blog, je ne souhaite pas écrire des articles sur comment monter son laboratoire d'analyse à base de VM. En effet, pour moi monter ce type de labo est une tache nécessaire mais dans laquelle je trouve peu d'intérêt intellectuel, je vous invite donc à suivre par exemple cet excellent guide afin de monter votre labo. Ainsi, vous pourrez faire exploser des malwares avec le plus de sécurité possible. Sachez néanmoins que même avec beaucoup de précautions (et surtout de rigueur), **le risque zero d'infection n'existe pas**.

Juste pour votre information, mon labo d'analyse est constitué de la manière suivante:
- Je n'utilise pas mon Mac de 'daily' pour cette activité
- Utilisation d'un desktop orienté Gaming **dédié**, sous UBUNTU, nommé WOPR ;-)
- Tout est **VM VMWARE** chez moi
- Chaque Malware analysé en Debug l'est évidement au sein d'une **VM** tournant sous Windows 11 avec [100% FLARE VM de MANDIANT](https://github.com/mandiant/flare-vm) d'installé (```Host Based Indicators```)
- Les toutes dernières versions de **FLARE VM** fonctionnent parfaitement avec Windows 11 (contrairement aux anciennes qui avaient des problèmes en W10 et W11)
- Les VM INFECTED ne communiquent pas avec le réseau du Desktop Hote (WOPR), ni avec le WIFI et internet : elles disposent de leur propre réseau virtuel privé en vase clos
- J'utilise l'excellent **RemNux** pour émuler les services internet de base (HTTPx, SSHD, SMTP, SMB, ...) et ainsi analyser les actions réseau des vilains canards (```Network Based Indicators```)
- L'ensemble des VM INFECTED sont stockées sur un disque dur SSD **externe** et **dédié**
- Le DD externe dédié avec son sticker BIOHAZARD est systématiquement débranché de l'hôte et rangé au tiroir
- Définition et strict respect de **Conventions de nommage des fichiers et des extensions** au sein des VM INFECTED
- Utilisation d'aucune extension dans les navigateurs des VM Infected (ex: n'allez pas y installer votre password manager pour gagner du temps )
- ET SURTOUT, je ne télécharge JAMAIS mes samples sur le Darkweb (je préfère GITHUB, MALWARE BAZAR oy ANY.RUN)

<p class="disclaimer">
Formez-vous sur tout cela AVANT de passer à la suite. Ne pas le faire vous expose de manière certaine à de gros problèmes.
</p>

<center>
<img width="800" src="/images/caution.png">
</center>

<center>
<img width="300" src="/images/explosion.png">
</center>

# GULOADER: On ouvre la boite

Vous avez lu le ```Disclaimer``` ci-dessus ? Alors on y va.

Ce qui caractérise GuLoader, et donc fait son intérêt d'étude, ce sont les nombreuses techniques d'anti-* qu'il utilise:

Contre les analyses dynamiques :
- **Anti-VM** : GuLoader vérifie l'absence de VMWare, QEMU, VirtualBox et se termine lors de toute détection
- **Anti-Sandbox** : Le malware vérifie l'absence de système de sand-boxing tel que ```Cuckoo Sandbox```
- **Anti-Debug** : GuLoader vérifie si il est exécuté sous un debugger tel que ```WinDbg``` ou ```OllyDbg```

Pour complexifier l'analyse statique :
- **Appels des API Windows**, non pas par leur nom, mais par leur hash ```DJB2```
- **Utilisation d'un VEH (Vectored Exception Handler)** pour piloter le flux d'exécution (plutôt que par des JUMP et des CALL)
- **Offuscation du binaire et utilisation d'_opaque predicates_**

Dans cette article, nous allons nous intéresser au Loader et à la désofuscation du shellcode. Nous traiterons la suite de l'analyse dans les articles suivants.

## Le script NSIS

Nous allons vite passer cette partie car là n'est pas l'aspect intéressant ce GuLoader.

Depuis quelques temps, mes analyses statiques de binaires commencent toute par un scan avec l'excellent [Detect It Easy](https://github.com/horsicq/Detect-It-Easy/tree/master/db) codé par [@horsicq](https://twitter.com/horsicq). 

Voici ce que DiE (lancé ici en mode console) pense de notre binaire mystère:
``` bash
naptax@WOPR:~/diec 14d52119459ef12be3a2f9a3a6578ee3255580f679b1b54de0990b6ba403b0fe.7z 

PE32
    Installer: Nullsoft Scriptable Install System(3.08)[lzma,solid]
    Linker: Microsoft Linker(6.0*)[GUI32,signed]
    Overlay: NSIS data(-)[-]

```
DiE nous indique que le binaire pourrait être une archive compressée au format **NSIS (Nullsoft Scriptable Install System)**.
Qui dit NSIS, dit _7-Zip_, alors ouvrons ce binaire avec _7-Zip_:

<img width="500" src="/images/guloader/guloader.1.png">

Encore une fois, _Detect It Easy_ avait vu juste. 
Intéressons-nous à ce gros fichier ```rudesbies.Par```

Là encore, un premier scan avec DiE:

``` bash
naptax@WOPR:~/diec rudesbies.Par
```
Mais cette fois, rien de connu dans la [DB de signatures DiE](https://github.com/horsicq/Detect-It-Easy/tree/master/db).


## Désofuscation du Shell Code Phase 1

Chargeons alors ce binaire dans **GHIDRA** ou **HOPPER** (c'est mon préféré après IDA). La première partie intéressante est ce petit bout de code, je vous ai mis en commentaire ce que nous pouvons en tirer:
Jusqu'à l'adresse, que du JUNK Code n'ayant aucun impact sur le flux d'exécution.

La première instruction intéressante se situe à ```+0x00000025```, un JMP qui nous mène sur un premier CALL ```+0x0000002A``` 

<img src="/images/guloader/guloader-bn-1.png">

Là encore, beaucoup de JUNK code, c'est pourquoi je n'ai conservé ci-dessous que les instructions de la fonction ```+0x0000002a``` qui nous intéressent:

<img src="/images/guloader/guloader-bn-2.png">



``` nasm
**************************************************************
*                          FUNCTION                          *
**************************************************************
undefined FUN_0000002a()
   
   (...)
        00000048 5f              POP        EDI   
   
   (...)
        00000065 31 d2           XOR        EDX,EDX

LAB_00000090:

    (...)
        000000b5 81 34 17        XOR        dword ptr [EDI + EDX*0x1],0x919e1e2e
    
    (...)
        000000db 83 c2 04        ADD        EDX,0x4
        000000f7 81 fa 08        CMP        EDX,0x17208
        000000fd 75 91           JNZ        LAB_00000090

```
- Le ```POP EDI``` stocke dans EDI la _return adress_ mis sur la pile au moment du ```CALL +0x0000002A``` 
- On met EDX à 0 (pour peut-être préparer une boucle ...)
- Ah :-) on XOR le code avec la clé ```0x91 9e 1e 2e```
- Et on boucle 0x17208/4 fois, en avançant par 4 octets

**Ok, on a donc une première boucle qui XOR tout le code à partir de l'adresse de l'adresse  avec ```0x919e1e2e```  comme clé.**

Créons un petit bout de RUST pour déchiffrer ce code offusqué:
``` rust
use std::fs::File;
use std::io::prelude::*;
use std::io::{BufReader, BufWriter};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt}; 

fn main() {
    let file = File::open("/home/naptax/tmp/rudesbies.Par").unwrap(); // J ouvre le fichier

    let mut reader = BufReader::new(file); // J'en produis un Buffer
    let mut enc_code = vec![]; // Crée un nouveau vecteur contenant des u8

    reader.read_to_end(&mut enc_code).unwrap(); // Charge le contenu du buffer dans mon vecteur
    
    let code_offset = 0x0000014E; // offset du début du code à XORer 
    enc_code = enc_code[code_offset..].to_vec();
    
    let key: u32 = 0x919E1E2E; // la clé avec laquelle est réalisé le XOR

    let mut out = vec![]; // Crée un vecteur qui va recevoir le code déchiffré
    
    for i in 0..enc_code.len() {
        out.push(enc_code[i] ^ key.to_le_bytes()[i % 4]); // fait le XOR
    }
    /* Le modulo 4 permet de s'assurer que la clé est utilisée de manière cyclique pour chacun des bytes de la variable enc_code 
    en utilisant toujours les 4 premiers bytes de la clé pour chiffrer les 8 premiers bytes de la variable enc_code, 
    les 4 prochains bytes de la clé pour chiffrer les 8 prochains bytes de la variable enc_code, etc. */
    
    let mut file = File::create("/home/naptax/tmp/stage2.bin").unwrap();
    let mut writer = BufWriter::new(file);
    
    writer.write_all(&out).unwrap();
}
```

Si vous préférez procéder au déchiffrement du code XORé en **interne dans  :heart: BINARY NINJA  :heart:**, plutôt qu'en externe (ici en RUST), alors voici le code Python pour BINARY NINJA:

``` Python
from binaryninja import *

xor_key = struct.pack('<I',0x919E1E2E)
code_offset = 0x0000014E
code_before = bytearray
code_after  = []

view = bv

start_addr = view.start + code_offset
end_addr = view.end

code_before = view.read(start_addr, end_addr - start_addr)
print(f'Binaire (size = {len(code_before)} ) AVANT le xor:\t', code_before[0:24])


for i in range(len(code_before)):
    code_after.append(code_before[i] ^ xor_key[i % len(xor_key)])

print(f'Binaire (size = {len(code_after)} ) APRES le xor:\t', bytearray(code_after[0:24]))


view.write(start_addr, bytearray(code_after))

view.update_analysis_and_wait()
```


Allez, on continue: regardons ce binaire _Stage 2_ dans  :heart: BINARY NINJA  :heart: (ou votre Disassembleur préféré).

## Désofuscation du Shell Code Phase 2 : Arrivée du hashing

Une première lecture du code désassemblé laisse septique: Encore et encore du JUNK code :-(
Néanmoins, à force de JMP vers des JMP ;=) on fini par identifier tout de même en ```0x22d``` les fonctions suivantes qui semblent procéder au calcul d'une constante:

<img width="750" src="/images/guloader/guloader-bn-22d.png">

On reconstitue ces constantes, ainsi :

``` c
hex((0x96900857 + 0x10E451D0) ^ 0xAA6DFF89 ^ 0xD19A097) = 
hex((0x191AE730 ^ 0x320EB5D5 ^ 0xB8DB25E1) + 0x6C3088FC) = 
hex((0xE22ECFA7 ^ 0xD05F809C ^ 0x4E1C381C) - 0x7C6D76C6) =

(0x1C90313A  ^ 0x0A3C51979 ^ 0x8A519DBE) - 0x3504B2FD = 
```

Si vous avez suivi mon petit article sur les techniques d'anti-disassembly, alors la constante x0 a du retenir votre attention.
En effet x0 est une valeur importante dans l'algorithme de hash xx; algo très souvent utilisé pour faire du hashing dans les malwares (tout comme la valeur 256 caractérise un chiffrement RC4: cf mon article sur ce sujet).

On aurait donc cette fonction qui implémenterait un hash. On va donc prendre cette hypothèse et la nommer comme tel:

Regardons maintenant qui appelle cette fonction de hash:

Mais dites-donc on serait pas en train d'essayer de nous masquer des appels API Windows par la technique d'API Hash Calling (ici sur mon blog) !!
Mais si ! Allez vous êtes vus, regardons les fonctions API appelée:



<img width="100" src="/images/monster-1.png">

Une fois déchiffré, on obtient alors le code assembleur suivant:

``` nasm

```


<center>
<img width="300" src="/images/wip.png">
</center>
