---
title: PROLOG 0x002, Les conventions d'appel
layout: post
---

<center>
<img width="150" src="/images/virus-4.png">
</center>

Comme leur nom l'indique, les conventions d'appels définissent des règles communes en matière de passage d'arguments et de valeurs retour vers et par une fonction. Bah oui me direz vous... mais voilà, la difficulté c'est qu'il existe plusieurs de ces conventions. Par exemple, elles sont différentes entre un LINUX 64-bit et un WINDOWS 64-bit, et encore différentes entre un Linux 32-bits et un Linux 64-bits .... 

Comme il en existe beaucoup, nous allons nous limiter aux conventions d'appels sur processeurs Intel X86 (32-bits et 64 bits). D'une maniére générale, je laisse de côté sur mon blog tout ce qui va concerner les processeurs ARM, et donc n'écrit pas pour les considérations niveau des MAC M1 construits sur un ARM64.

Avant de parler des OS (LINUX et WINDOWS 64-bits), étudions 3 des principales conventions d'appel que l'on rencontre dans les architectures **32-bits** Intel :
- `cdecl`
- `stdcall`
- `fastcall`

### `CDECL`

Cette convention d'appel est largement utilisée par les compilateurs C sur la plateforme X86 **32-bits**
.
En convention `cdecl` la responsabilité de nettoyage de la stack **incombe à la procédure appelante** (je vous renvoie au billet précédent pour cerner les notions essentielles de Stack, appelant, appelée).

Les principales (liste non-exaustive) propriétés de cette convention d'appel sont:

- les arguments sont passés aux fonctions par la stack
- les valeurs retours des fonctions sont renvoyées par le **registre EAX** pour les entiers
- les valeurs retours des fonctions sont renvoyées par le **registre x87 ST0** pour les réels
- les registres EAX, ECX et EDX doivent etre sauvegardés par l'appelant
- tous les autres registres doivent etre sauvegardés (au besoin) par l'appelé



### `STDCALL`

Cette convention est utilisée pour les appels de fonctions de **l'API Win32**.

Les principales (liste non-exaustive) propriétés de cette convention d'appel sont:

- Cette fois-ci, c'est à la **fonction appelée** qu'incombe la responsabilité de nettoyer la stack
- les arguments sont passés de la droite vers la gauche
- les valeurs retours des fonctions sont renvoyées par le **registre EAX** pour les entiers et les adresses
- les valeurs retours des fonctions sont renvoyées par les **registres DX, BX, AX** pour les réels
- les registres EAX, ECX et EDX doivent etre sauvegardés par l'appelant
- tous les autres registres doivent etre sauvegardés (au besoin) par l'appelé

### `Microsoft FASTCALL`

Les principales (liste non-exaustive) propriétés de cette convention d'appel sont:

- utilise les registres ECX et EDX pour passer les 2 premiers arguments (de la gauche vers la droite) à la fonction appelée. Puis utilise la stack pour passer les arguments suivants (mais cette fois-ci de le la droite vers la gauche)
- c'est à la **fonction appelée** qu'incombe la responsabilité de nettoyer la stack

Attention, sur un OS 64 bits, les compilateurs ignoreront (sans lever d'erreur) la directive `__fastcall`. En effet, ces compilateurs doivent produire du code respectant l'ABI de l'OS. Et pour les conventions 64-bits, c'est juste en dessous ...

------
<center>
<img width="150" src="/images/64-bits.png">
</center>

Basculons maintenant dans le monde merveilleux des **OS 64-bits**, monde qui se décompose principalement en 2 conventions d'appel:
- Linux 64-bit (_System V AMD64 ABI_)
- Windows 64-bit (_fastcall_)



### Linux 64-bit


### Windows  64-bit

-- 

S'il n'y a pas de registres disponibles pour les huit octets d'un argument, l'argument entier
est passé sur la pile. Si des registres ont déjà été affectés pour environ huit octets de tels
un argument, les affectations sont annulées.
Une fois les registres assignés, les arguments passés en mémoire sont poussés sur la pile
dans l'ordre inverse (de droite à gauche21).
Pour les appels qui peuvent appeler des fonctions qui utilisent varargs ou stdargs (appels sans prototype ou appels
aux fonctions contenant des points de suspension (. . . ) dans la déclaration) %al22 est utilisé comme argument caché
pour spécifier le nombre de registres vectoriels utilisés. Le contenu de %al n'a pas besoin de correspondre
exactement le nombre de registres, mais doit être une limite supérieure sur le nombre de vecteurs
registres utilisés et est compris entre 0 et 8 inclus.
Lors du passage des arguments __m256 ou __m512 aux fonctions qui utilisent varargs ou stdarg,
des prototypes de fonction doivent être fournis. Sinon, le comportement d'exécution est indéfini.
Retour des valeurs Le retour des valeurs se fait selon le algorithme suivant :
1. Classifiez le type de retour avec l'algorithme de classification.
2. Si le type a la classe MEMORY, l'appelant fournit de l'espace pour la valeur de retour
   et passe l'adresse de ce stockage en %rdi comme s'il s'agissait du premier argument du
   fonction. En effet, cette adresse devient un premier argument "caché". Ce stockage
   ne doit chevaucher aucune donnée visible par l'appelé via d'autres noms que cet argument.
   Au retour %rax contiendra l'adresse qui a été passée par l'appelant dans %rdi.
3. Si la classe est INTEGER, le prochain registre disponible de la séquence %rax, %rdx est
   utilisé.
4. Si la classe

--