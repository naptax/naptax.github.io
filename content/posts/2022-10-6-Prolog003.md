---
author: "Naptax"
title: "PROLOG 0x003, Un premier Stack Buffer Overflow (simple)"
date: "2022-09-26"
tags: 
- prolog
- bof
---

<center>
<img width="150" src="/images/virus-dancing.webp">
</center>

Hello,

Comme vous avez soigneusement lu les **3 premiers billets de la série PROLOG** (si celà n'est pas le cas, je vous invite vivement à les lire avant celui-ci : [Assembler(1)]({{< relref "2022-10-6-Prolog000" >}}), [Mémoire(2)]({{< relref "2022-10-6-Prolog001" >}}), [conventions d'appels(3)]({{< relref "2022-10-6-Prolog002" >}})) est venu le temps de les mettre en application. 

Et pour un premier excercice, la compréhension d'un Buffer Overflow est parfaite. A ce stade de la pédagogie, nous allons prendre un exemple fictif avec une simplicité que vous ne trouverez pas sur le théatre des opérations. En effet, les OS et compilateurs ont depuis longtemps mis en place de nouveaux moyens de protection contre l'exploitation de ces dépassements de buffer : pile non-exécutable, allocation mémoire aléatoire, canary, ...

Un peu plus tard, nous verons que ces moyens de protections sont eux aussi 'bypassable' ...

Je ne ferai pas de rappel théorique dans ce billet, pour celà je vous renvoie aux billets PROLOG précédants.


<center>
<img width="150" src="/images/overflow.png">
</center>

## Mais c'est quoi un BOF ?

Un Buffer OverFlow, c'est comme son nom l'indique le fait de transférer dans une zone mémoire pré-dimensionnée, une quantité d'informations dont la taille est supérieure à cette zone mémoire. Plus précisément, un BOF consiste **à provoquer ce débordement et à exploiter les effets de bord provoqués par ce débordement**.

Il existe plusieurs zones mémoire d'attaque possible pour un Buffer Oveflow (Heap, Stack, ...). Nous allons ici étudier la plus répendue : le **STACK** Buffer Overflow.
Le Stack BOF consiste donc à utiliser une erreur de programation pour faire exécuter à un programme légitime, du code à nous (ex: un shell code pour nous donner un beau shell sur la machine).

</BR>

<center>
<p>
<b>Notre objectif est donc de venir écraser la valeur du registre EIP/RIP par une adresse de notre de choix, et ce, afin d'orienter le flux d'éxécution sur du code que nous aurions préalablement injecté em mémoire.</b>
</p>
</center>

<center>
<img width="150" src="/images/debug.png">
</center>

## Le vilain petit programme

Afin de pouvoir étudier simplement un premier BOF, il nous faut un programme vulnérable. Dans un soucis de pédagogie, nous allons prendre le vilain listing suivant :

``` c
#include <stdio.h>


void donner(char *ongName, int montant) {
    printf("Vous avez fait un don de %d euros a l'ONG %s.\n", montant, ongName);
}

int main(int argc, char *argv[]){
    char ong[8];
    int montant = 1000;
    printf("Faire un don\n-------------\n\n");
    printf("\t A quelle ONG souhaitez-vous faire votre don ?\n \t >  ");
    gets(ong);
    donner(ong, montant);
    printf("Un grand MERCI\n");
    return 0;
}
```

Afin de pouvoir faire un peu joujou simplement, il nous faut compiler ce programme avec les directives qui suppriment les différentes protections mises en place par les compilateurs et OS récents.

``` bash
$ gcc -no-pie -fno-stack-protector -o bof-1 bof-1.c
```




## Notre outil : RADARE2

Pour nous changer un peu de GDB, je vous propose dans cet exemple d'utiliser **mon débugueur en ligne de commande préféré**, le magnifique **`RADARE2`**.

RADARE2 est un framework open source pour le Reverse engineering et l'analyse de binaire. R2 implémente une interface de ligne de commande riche pour désassembler, analyser des données, corriger des binaires, comparer des données, rechercher, remplacer. Il a de grandes capacités de script, il est disponible sur les principaux OS (Linux, Windows, OSX,…). R2 est extrement puissant et totalement gratuit. 

RADARE2 se compose d'un ensemble d'utilitaires qui peuvent être utilisés ensemble à partir du shell R2 ou indépendamment.

Les premieres utilisations du CLI RADARE2 peuvent un peu déstabiliser au départ. En effet les commandes sont nombreuses (car l'outil est puissant) et utilise une syntaxe courte (bien souvent 2 ou 3 lettres). **Mais une fois vos commandes usuelles rapidement mémorisées, vous bénéficierez d'une vélocité très élevée.** Il existe sur le net myriades de cheatsheets dont je vous conseille une belle impression en A3 pour vos premières semaines avec le bolide.

J'expliciterai ici les commandes que nous allons utiliser et je vous renvoi au site officiel de RADARE2 pour une formation détailée à ce framework de reverse.

Allez, on charge notre vilain binaire sous notre microscope electronique RADARE2:

```r2 -d bof-1.exe GREENPEACE```

<center>
<img src="/images/wip.png">
</center>

