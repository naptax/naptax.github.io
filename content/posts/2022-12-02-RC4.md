---
author: "Naptax"
title: "Crypto 0x001: RC4"
date: "2022-12-02"
tags: 
- crypto
draft: false
---

<center>
<img width="500" src="/images/chut.png">
</center>

**Hello**,

Les auteurs de Malware écrivent le code de leur payload avec 3 préoccupations techniques principales:

1. Atteindre l'objectif malicieux (Chiffrer, Voler, Evader, Détruire, Usurper) : c'est la raison d’être de leur Payload
2. Passer sous les radars des logiciels de sécurité (ex: EDR, AV) en étant le plus discret et surtout atypique possible
3. Rendre la tache des Malware Analysts la plus complexe possible (Anti-Debug tricks, cryptage, offuscation, ...)

C'est pourquoi les malwares font une utilisation intensive de différents algo de **chiffrement** symétriques et asymétriques.
Il est donc nécessaire d'en maîtriser quelques-uns pour pouvoir identifier et comprendre "le petit manège".

Je vous propose de commencer par **le plus simple** de ces algo de chiffrement : RC4

# Son histoire
RC4 (Rivest Cipher 4) est un algorithme de chiffrement en continu conçu en 1987 par Ronald Rivest (l'un des inventeurs du RSA).
Les détails de RC4 furent initialement tenus secrets mais en 1994, une description du chiffrement fut postée de manière anonyme sur la liste de diffusion [USENET alt.cypherpunks](https://cryptoanarchy.wiki/getting-started/what-is-the-cypherpunks-mailing-list).

RC4 a été utilisé dans des protocoles comme WEP, WPA et TLS. 

Les raisons de son succès sont liées à sa grande simplicité et à sa vitesse de chiffrement. En revanche, son utilisation dans le cadre de protocole de sécurité est terminée en raison de certaines faiblesses mise à jour. En effet RC4 n'utilise pas de vecteur d'initialisation, en plus de la clé. Un vecteur d'initialisation indépendant de la clé permet de garantir une sécurité suffisante. Ainsi les même messages chiffrés deux fois avec la même clé ne produisent pas la même sortie. **Malgré ses faiblesses, RC4 est encore massivement utilisé par les malwares**.

RC4 est un algorithme de **chiffrement en continu, également appelé chiffrement par flot (stream cipher)**. Le chiffrement par flot est l'une des deux grandes catégories de chiffrements modernes en cryptographie **symétrique**; l'autre étant le chiffrement par bloc. Un chiffrement par flot est constitué d'un générateur de nombres pseudo-aléatoires avec lequel on opère un XOR entre un bit à la sortie du générateur et un bit provenant du message à chiffrer.

Aux cotés de RC4, l'on trouve d'autres (plus modernes et plus sécurisés) algo de chiffrement par flux : notamment **SALSA 20**, dont on remarque l'utilisation croissante dans les malwares.

# Principe du chiffrement RC4

La clé RC4 permet d’initialiser un tableau de 256 octets en répétant la clef autant de fois que nécessaire pour remplir le tableau. Par la suite, des opérations très simples sont effectuées : les octets sont déplacés dans le tableau, des additions sont effectuées, etc. Le but est de mélanger autant que possible le tableau. On obtient alors une suite de bits pseudo-aléatoires qui sont utilisés pour chiffrer les données via un XOR.

Nous avons donc une séquence de chiffrement/déchiffrement très simple, composée des 4 étapes séquentielles suivantes :

1. Initialisation de notre tableau d'état
2. KSA du tableau d'état avec notre clé
3. Generation du Keystream avec un PRNG
4. Exécution du XOR "membre a membre" entre l input et le Keystream 

Chacune de ces étapes sont simples et trés identifiables (nous allons y revenir ...)

# La pratique en C

Vous trouverez ci-dessous mon implémentation de RC4 en C. Celle-ci n'est pas optimisée et vous en trouverez certainement des meilleures sur le net. Par exemple, je laisse le soin au compilateur C de trouver la meilleure optimisation de mes opérations de `modulo` (nous allons vite disséquer/vérifier cela en ASM reversé...) Néanmoins j'estime qu'implémenter soi-meme un RC4 est un exercice intéressant. 

**Toutes les explications sont dans les commentaires**.

{{< gist naptax 4019fb213871ad933436c9646d334480 "RC4Impl.c" >}}

<center>
<img width="300" src="/images/clue.png">
</center>

# Identifier l'usage de RC4 dans un code binaire

Maintenant que nous connaissons un peu mieux RC4, on peut en tirer les macro-facteurs d'identification suivants (tous reliés par un AND ;-) :

- Commence par une boucle d'init de 256 (100h) 
- Réalise des Modulo 256 (100h)
- Une boucle KSA de 100h itérations 
- Procède à des swaps 
- Utilise une clé unique 

Compilons notre implémentation exemple, puis posons la sous notre microscope IDA afin de pointer chacune des étapes. Comme nous sommes en mode tuto, j'ai été sympa et j'ai compilé le programme C en incluant les informations de debug dans le binaire ;-) , évidemment dans le malware cela ne sera jamais le cas (sauf pour les plus mauvais d'entres-eux).

**Mais avant d'ouvrir IDA, il nous faut faire un focus sur la fonction MODULO**.

## Reconnaitre un modulo en assembleur

Il existe plusieurs manières d'implémenter un *mod 256* en ASM:

1. Une **très/trés lente**, basée sur des DIV ou IDIV (que tout compilateur moderne ne générera pas) [ici pour creuser le sujet](https://stackoverflow.com/questions/41183935/why-does-gcc-use-multiplication-by-a-strange-number-in-implementing-integer-divi)
2. Une optimisée, reposant sur des décalages de bit

#### The good Way

256 étant un nombre pair (c-á-d dont la division euclidienne par 2 donne un reste à 0), alors nous allons pouvoir calculer notre modulo par décalage de bit.
Rappelons les principes du décalage de bit:

- Décaler de N bits vers la droite (>>) revient à diviser par 2 puissance N 
- Décaler de N bits vers la gauche (<<) correspond à une multiplication par 2 puissance N

``` c
short a = 0b00011100; // soit 28 en décimal
short b;
b = a << 2;
// b vaut maintenant 0b01110000 // 112, soit 28 * 2^2  
b = a >> 4;
// b vaut maintenant 0b00000001 // 1, soit 28 / 2^4
a <<= 3;
// a vaut maintenant 0b11100000 // 224, soit 28 * 2^3
```

<center>
<b>(....)</b>
</center>

<center>
<img width="300" src="/images/wip.png">
</center>