---
author: "Naptax"
title: "PROLOG 0x004, Local Shellcode par Stack Buffer OverFlow (Part 2) "
date: "2022-09-26"
tags: 
- prolog
- bof
---

<center>
<img width="150" src="/images/ptitfantome.png">
</center>

**Hello**,

Toujours dans cette série de billets d'ouverture (aka PROLOG), nous nous étions laissés la derniere fois sur un billet expliquant ce qu'était un BUFFER OVERFLOW (le billet est ici). Je vous propose maintenant de passer à la pratique en obtenant un Shell par l'utilisation d'un STACK Buffer Overflow.

Toujours dans un soucis de pédagogie, nous allons prendre un exemple simple :
- Une erreur de programmation flagrante
- Un executable ne disposant d'aucun moyen de protection de sa stack 
- Un OS pour lequel nous aurions désactivé l'ADSLR qui le protège de ce type d'exploitation
- Une execution locale (et non remote)

Un peu plus tard, nous verrons que ces moyens de protection, meme activés, sont eux aussi 'bypassable' ...

Je ne ferai pas de rappel théorique dans ce billet, pour celà je vous renvoie aux billets PROLOG précédants.


# Le principe de base du Stack Buffer Overflow
Un peu d'histoire et de remerciements .....

Le principe de base consiste donc à venir écraser la valeur présente à l'adresse de retour lors de l'appel d'une fonction.
Cette valeur d'EIP/RIP ayant été préalablement (et automatiquement) sauvegardée sur la pile au moment du CALL de cette fonction. La sauvegarde automatique par l'instruction CALL de cette valeur est nécéssaire afin de pouvoir rebrancher le flux d'éxécution une fois l'éxécution de la fonction terminée. "Bah Oui, je vais où moi maintenant ? demande le processeur ;-)

Plus précisément, nous souhaitons REMPLACER/SUBSITUER cette valeur (une adresse mémoire) par une une autre adresse; adresse sur laquelle nous aurions préalablement 'posé' notre Shellcode (ou toute autre forme de Payload).

Donc, nous allons profiter de pouvoir écrire au delà de la taille attendue (cf le Billet sur le Buffer Overflow), pour poser une chaine de caractères qui sera exécutée par le processeur.

# Le vilain programme

Je sais, il est vilain, mais il va nous permettre d'apprendre ;-)

``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


void donne(int montant){  
   char ong[15];         
   
   printf("A quelle ONG spuhaitez-vous faire un don ? \n");
   gets(ong);
   printf("Vous avez fait un don de %d euros a l'ONG %s.\n", montant, ong);
}


int main(int argc, char *argv[]){
    int montant = 1000;

    donne(montant);
    printf("Un grand MERCI cher donnateur !\n");                        
    exit(0);
    }
```

A compiler avec tous les mécanismes de protection désactivés

` gcc -fno-stack-protector -nopie bof.c -o bof `

# Comment déterminer cette adresse ?
Il existe plusieurs techniques pour trouver cette adresse, je v